using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Windows.Documents;
using TypeScriptAnalyzerEslintLinter;
using Task = System.Threading.Tasks.Task;

namespace TypeScriptAnalyzerEslintTest
{
    /// <summary>
    /// Tests use of parsers configured in various ways
    /// All tests use the same a.ts file that contains TypeScript syntax that the standard (JavaScript) espree parser can't handle
    /// </summary>
    [TestClass]
    public class ParserTest
    {
        public TestContext TestContext { get; set; } = null;

        [TestMethod, TestCategory("Parser")]
        public async Task ParserNotSpecified()
        {
            // If we don't specify a parser in .eslintrc.js then the web server should default to using the typescript-eslint parser
            // provided in the TypeScript Analyzer installation: that is it should be able to parse our a.ts file containing TypeScript.
            // It was this breaking Feb 2024 after the release of v6.0.0 of @typescript-eslint that lead to these tests being added.
            // Note that we do this by setting options.baseConfig in server.js, the webserver code
            await ThreadHelper.JoinableTaskFactory.SwitchToMainThreadAsync(TestContext.CancellationToken);
            LintingResult result = await new Linter(MockSettings.Instance)
                .LintAsync(new string[] { Path.Combine(VisualStudioVersion.GetArtifactsFolder(), @"parser\parsernotspecified\a.ts") }, new string[] { });
            Assert.IsTrue(result.HasErrors);
            Assert.IsFalse(string.IsNullOrEmpty(result.Errors.First().FileName), "File name is empty");
            Assert.HasCount(3, result.Errors);
            List<LintingError> errorList = result.Errors.ToList();
            Assert.AreEqual("'Unused' is defined but never used.", errorList[0].Message);
            Assert.AreEqual("@typescript-eslint/no-unused-vars", errorList[0].ErrorCode);
            Assert.AreEqual("Unexpected var, use let or const instead.", errorList[1].Message);
            Assert.AreEqual("no-var", errorList[1].ErrorCode);
        }

        [TestMethod, TestCategory("Parser")]
        public async Task ParserIncorrectlySpecified()
        {
            // If we specify a parser in .eslintrc.js but we don't include a correct path we should error with an appropriate message
            await ThreadHelper.JoinableTaskFactory.SwitchToMainThreadAsync(TestContext.CancellationToken);
            LintingResult result = await new Linter(MockSettings.Instance)
                .LintAsync(new string[] { Path.Combine(VisualStudioVersion.GetArtifactsFolder(), @"parser\parserincorrectlyspecified\a.ts") }, new string[] { });
            Assert.IsTrue(result.HasErrors);
            Assert.IsFalse(string.IsNullOrEmpty(result.Errors.First().FileName), "File name is empty");
            Assert.HasCount(1, result.Errors);
            Assert.StartsWith("ESLint webserver error. For more details see Output window: Failed to load parser", result.Errors.First().Message);
        }

        [TestMethod, TestCategory("Parser")]
        public async Task EspreeParserSpecified()
        {
            // .eslintrc.js specifies the espree parser, which can't deal with TypeScript syntax so we should get errors re our a.ts file
            await ThreadHelper.JoinableTaskFactory.SwitchToMainThreadAsync(TestContext.CancellationToken);
            LintingResult result = await new Linter(MockSettings.Instance)
                .LintAsync(new string[] { Path.Combine(VisualStudioVersion.GetArtifactsFolder(), @"parser\espreeparserspecified\a.ts") }, new string[] { });
            Assert.IsTrue(result.HasErrors);
            Assert.IsFalse(string.IsNullOrEmpty(result.Errors.First().FileName), "File name is empty");
            Assert.HasCount(1, result.Errors);
            Assert.AreEqual("Parsing error: Unexpected token GreetingLike", result.Errors.First().Message);
            Assert.IsNull(result.Errors.First().ErrorCode);  // Error is not generated by the linter, but by being unable to parse
        }

        [TestMethod, TestCategory("Parser")]
        public async Task TypeScriptParserSpecified()
        {
            // .eslintrc.js specifically specifies the typescript-eslint parser, by path, and we should get the same results as ParserNotSpecified
            // above, which defaults to the same parser
            await ThreadHelper.JoinableTaskFactory.SwitchToMainThreadAsync(TestContext.CancellationToken);
            LintingResult result = await new Linter(MockSettings.Instance)
                .LintAsync(new string[] { Path.Combine(VisualStudioVersion.GetArtifactsFolder(), @"parser\typescriptparserspecified\a.ts") }, new string[] { });
            Assert.IsTrue(result.HasErrors);
            Assert.IsFalse(string.IsNullOrEmpty(result.Errors.First().FileName), "File name is empty");
            Assert.HasCount(3, result.Errors);
            List<LintingError> errorList = result.Errors.ToList();
            Assert.AreEqual("'Unused' is defined but never used.", errorList[0].Message);
            Assert.AreEqual("@typescript-eslint/no-unused-vars", errorList[0].ErrorCode);
            Assert.AreEqual("Unexpected var, use let or const instead.", errorList[1].Message);
            Assert.AreEqual("no-var", errorList[1].ErrorCode);
        }

    }
}
